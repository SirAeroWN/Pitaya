using Basic.Reference.Assemblies;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using CLIParserSourceGenerator;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Collections.Immutable;

namespace CLIParserSourceGeneratorTests
{
    internal static class CompilationHelpers
    {
        public static readonly CSharpCompilationOptions CSharpCompilationOptions = new CSharpCompilationOptions(
            outputKind: OutputKind.DynamicallyLinkedLibrary,
            deterministic: true,
            nullableContextOptions: NullableContextOptions.Enable
        );

        /// <summary>
        /// Extract errors from the given <paramref name="emitResult"/> in a user readable format.
        /// </summary>
        /// <param name="emitResult"></param>
        /// <returns></returns>
        public static string GetErrors(EmitResult emitResult)
        {
            if (emitResult.Success)
            {
                return "";
            }

            var sb = new StringBuilder();
            foreach (Diagnostic error in emitResult.Diagnostics)
            {
                sb.AppendLine(error.ToString());
            }

            return sb.ToString();
        }

        public static System.Reflection.MethodInfo GetMethod(Type type, string methodName, System.Reflection.BindingFlags bindingFlags = System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)
        {
            System.Reflection.MethodInfo? method = type.GetMethod(methodName, bindingFlags);
            Assert.IsNotNull(method, $"Could not load {methodName} from {type.FullName}");
            return method;
        }

        public static Type GetType(System.Reflection.Assembly assembly, string typeName)
        {
            Type? type = assembly.GetType(typeName);
            Assert.IsNotNull(type, $"Could not load {typeName} from {assembly.FullName}");
            return type;
        }

        public static Func<string[], int?> CompileProgram(string program, INamedTypeSymbol mainType, string mainReturnType, string assemblyName, List<OptionInfo> optionInfos, List<string> commentContent)
        {
            var overallSourceGenerator = new OverallSourceGeneratorExposed(mainType, mainReturnType, assemblyName, optionInfos, commentContent);
            string source = overallSourceGenerator.GenerateSource();

            // build against netstandard2.0
            List<MetadataReference> references = ReferenceAssemblies.NetStandard20.Cast<MetadataReference>().ToList();

            // compile the generated code
            CSharpCompilation compilation = CSharpCompilation.Create(
                "gen.dll",
                new List<SyntaxTree>() { CSharpSyntaxTree.ParseText(source), CSharpSyntaxTree.ParseText(program) },
                references: references,
                options: CompilationHelpers.CSharpCompilationOptions
            );

            return CreateRunnable(compilation);
        }

        public static Func<string[], int?> CreateRunnable(Compilation compilation)
        {
            using (var stream = new MemoryStream())
            {
                EmitResult emitResults = compilation.Emit(stream);
                if (!emitResults.Success)
                {
                    Assert.Fail(CompilationHelpers.GetErrors(emitResults));
                }

                stream.Seek(0, SeekOrigin.Begin);
                System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(stream.ToArray());

                Type autoProgramType = CompilationHelpers.GetType(assembly, "CLIParserSourceGeneratorTests.AutoGeneratedProgram");
                object? testClassInstance = Activator.CreateInstance(autoProgramType);
                Assert.IsNotNull(testClassInstance);

                // return the main method
                System.Reflection.MethodInfo method = CompilationHelpers.GetMethod(autoProgramType, "Main", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static);
                int? RunMain(string[] args)
                {
                    object? returnVal = method?.Invoke(testClassInstance, [args]);
                    return (int?)returnVal;
                }

                return RunMain;
            }
        }


        public static Compilation CreateCompilation(string source)
            => CSharpCompilation.Create(
                "gen.dll",
                new List<SyntaxTree>() { CSharpSyntaxTree.ParseText(source) },
                references: ReferenceAssemblies.NetStandard20.Cast<MetadataReference>().ToList(),
                options: CompilationHelpers.CSharpCompilationOptions
            );

        public static void CompileAndRunGenerator(string program, out Compilation outputCompilation, out ImmutableArray<Diagnostic> diagnostics)
        {
            var compilation = CreateCompilation(program);
            var generator = new PitayaSourceGenerator();
            GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
            driver.RunGeneratorsAndUpdateCompilation(compilation, out outputCompilation, out diagnostics);
        }
    }
}