using CLIParserSourceGeneratorTests.Fakes;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using CLIParserSourceGenerator;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLIParserSourceGeneratorTests
{
    [TestClass]
    public class ParserGeneratorTests
    {
        private static readonly string _optionsClassName = "AutoGeneratedCLIOptionsHolder";

        [TestMethod]
        public void CreateTest()
        {
            List<OptionInfo> options = [
                OptionInfo.Create(FakeParameterInfo.Create(parameterName: "aValue"))
                , OptionInfo.Create(FakeParameterInfo.Create(parameterName: "anUnsignedInt", typeName: "uint", hasDefaultValue: true, defaultValue: 1))
            ];

            var parserGenerator = new ParserGenerator(options, _optionsClassName);
            Assert.AreEqual("AutoGeneratedCLIParser", parserGenerator.ClassName);
        }

        [TestMethod]
        public void GenerateAndedSetValuesTest()
        {
            List<OptionInfo> options = [
                OptionInfo.Create(FakeParameterInfo.Create(parameterName: "aValue"))
                , OptionInfo.Create(FakeParameterInfo.Create(parameterName: "anotherValue"))
                , OptionInfo.Create(FakeParameterInfo.Create(parameterName: "yetAnotherValue"))
            ];

            var parserGenerator = new ParserGeneratorExposed(options, _optionsClassName);
            var andedSetValues = parserGenerator.GenerateAndedSetValuesExposed();
            string expected = "options._aValueValueSet && options._anotherValueValueSet && options._yetAnotherValueValueSet";
            Assert.AreEqual(expected, andedSetValues.ToFullString());
        }

        [TestMethod]
        public void GenerateAndedSetValues_SomeOptional_Test()
        {
            List<OptionInfo> options = [
                OptionInfo.Create(FakeParameterInfo.Create(parameterName: "aValue"))
                ,
                OptionInfo.Create(FakeParameterInfo.Create(parameterName: "anotherValue", typeName: "uint", hasDefaultValue: true, defaultValue: 1))
                ,
                OptionInfo.Create(FakeParameterInfo.Create(parameterName: "yetAnotherValue"))
            ];

            var parserGenerator = new ParserGeneratorExposed(options, _optionsClassName);
            var andedSetValues = parserGenerator.GenerateAndedSetValuesExposed();
            string expected = "options._aValueValueSet && options._yetAnotherValueValueSet";
            Assert.AreEqual(expected, andedSetValues.ToFullString());
        }

        [TestMethod]
        public void GenerateHelpSectionTest()
        {
            List<OptionInfo> options = [
                OptionInfo.Create(FakeParameterInfo.Create(parameterName: "aValue"))
            ];

            var parserGenerator = new ParserGeneratorExposed(options, _optionsClassName);
            var helpSection = parserGenerator.GenerateHelpSectionExposed();
            string expected = """
                case "-h":
                case "-?":
                case "--help":
                    options.___ShowHelp___ = true;
                    break;
                """;
            Assert.AreEqual(expected, helpSection.NormalizeWhitespace().ToFullString());
        }

        [TestMethod]
        public void GenerateSourceTest()
        {
            List<OptionInfo> options = [
                OptionInfo.Create(FakeParameterInfo.Create(parameterName: "aValue"))
                , OptionInfo.Create(FakeParameterInfo.Create(parameterName: "anotherValue", typeName: "uint", hasDefaultValue: true, defaultValue: 1))
                , OptionInfo.Create(FakeParameterInfo.Create(parameterName: "yetAnotherValue", typeName: "string"))
            ];

            var parserGenerator = new ParserGenerator(options, _optionsClassName);
            var source = parserGenerator.GenerateSource();
            string expected = """
                internal class AutoGeneratedCLIParser
                {
                    public AutoGeneratedCLIOptionsHolder Parse(string[] args)
                    {
                        AutoGeneratedCLIOptionsHolder options = new();
                        for (int i = 0; i < args.Length && !options.___ShowHelp___; i++)
                        {
                            string arg = args[i];
                            i++;
                            switch (arg)
                            {
                                case "--a-value":
                                    options.aValue = int.Parse(args[i]);
                                    options._aValueValueSet = true;
                                    break;
                                case "--another-value":
                                    options.anotherValue = uint.Parse(args[i]);
                                    break;
                                case "--yet-another-value":
                                    options.yetAnotherValue = args[i];
                                    options._yetAnotherValueValueSet = true;
                                    break;
                                case "-h":
                                case "-?":
                                case "--help":
                                    options.___ShowHelp___ = true;
                                    break;
                                default:
                                    throw new ArgumentException($"'{arg}' is not a recognized option");
                            }
                        }

                        if (!options.___ShowHelp___ && !(options._aValueValueSet && options._yetAnotherValueValueSet))
                        {
                            List<string> missing = new();
                            if (!options._aValueValueSet)
                            {
                                missing.Add("--a-value");
                            }

                            if (!options._yetAnotherValueValueSet)
                            {
                                missing.Add("--yet-another-value");
                            }

                            throw new ArgumentException($"Missing required argument{(missing.Count > 1 ? "s" : "")}: {string.Join(", ", missing)}");
                        }

                        return options;
                    }
                }
                """;
            Assert.AreEqual(expected, source);
        }

        [TestMethod]
        public void GenerateSource_Array_Test()
        {
            List<OptionInfo> options = [
                OptionInfo.Create(FakeParameterInfo.Create(parameterName: "aValue", type: FakeParameterInfo.ArrayTypeSymbol(null)))
            ];

            var parserGenerator = new ParserGenerator(options, _optionsClassName);
            var source = parserGenerator.GenerateSource();
            string expected = """
                internal class AutoGeneratedCLIParser
                {
                    public AutoGeneratedCLIOptionsHolder Parse(string[] args)
                    {
                        AutoGeneratedCLIOptionsHolder options = new();
                        for (int i = 0; i < args.Length && !options.___ShowHelp___; i++)
                        {
                            string arg = args[i];
                            i++;
                            switch (arg)
                            {
                                case "--a-value":
                                    for (; i < args.Length; i++)
                                    {
                                        arg = args[i];
                                        if (arg.StartsWith("-") && (arg.StartsWith("--") || arg == "-h" || arg == "-?"))
                                        {
                                            i--;
                                            break;
                                        }
                                        else
                                        {
                                            options._aValueBackingList.Add(int.Parse(args[i]));
                                        }
                                    }

                                    options._aValueValueSet = true;
                                    break;
                                case "-h":
                                case "-?":
                                case "--help":
                                    options.___ShowHelp___ = true;
                                    break;
                                default:
                                    throw new ArgumentException($"'{arg}' is not a recognized option");
                            }
                        }

                        if (!options.___ShowHelp___ && !(options._aValueValueSet))
                        {
                            List<string> missing = new();
                            if (!options._aValueValueSet)
                            {
                                missing.Add("--a-value");
                            }

                            throw new ArgumentException($"Missing required argument{(missing.Count > 1 ? "s" : "")}: {string.Join(", ", missing)}");
                        }

                        return options;
                    }
                }
                """;
            Assert.AreEqual(expected, source);
        }
    }

    class ParserGeneratorExposed : ParserGenerator
    {
        public ParserGeneratorExposed(List<OptionInfo> options, string optionsClassName) : base(options, optionsClassName)
        {
        }

        public ExpressionSyntax GenerateAndedSetValuesExposed()
        {
            return this.GenerateAndedSetValues();
        }
        public SwitchSectionSyntax GenerateHelpSectionExposed()
        {
            return this.GenerateHelpSection();
        }
    }
}
